{"version":3,"sources":["../turbosort.js"],"names":["Sorter","SIZE","buckets","Uint32Array","counts","indexFunction","identity","getMinMax","array","offset","length","firstIndex","minNum","maxNum","previousNum","inOrder","i","index","min_max_result","min","max","a","turboSort","size","func","Math","turboSortHelper","sorted","minimum","mini","val","maximum","maxi","quickSort","quickSortHelper","items","left","right","partition","pivot","floor","j","swap","arrayInfo","range","bucketSize","voyager","bucketId","newSpot","b","temp","turbosort","quicksort"],"mappings":"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","file":"turbosort.js","sourcesContent":["var Sorter = (function() {\n\n    const SIZE = 1000000;\n    const buckets = new Uint32Array(SIZE+1);\n    const counts = new Uint32Array(SIZE+1);\n    let indexFunction = identity;\n\n    /**\n     *  FUNCTION DEFINITIONS\n     */\n    function getMinMax(array, offset, length) {\n        let firstIndex = indexFunction(array[offset]);\n        let minNum = firstIndex;\n        let maxNum = firstIndex;\n        let previousNum = firstIndex;\n        let inOrder = true;\n        for(let i=1; i<length; i++) {\n            const index = indexFunction(array[offset+i]);\n            if(previousNum > index) {\n                inOrder = false;\n                if(index < minNum) {\n                    minNum = index;\n                }\n            } else {\n                if(index > maxNum) {\n                    maxNum = index;\n                }\n            }\n            previousNum = index;\n        }\n        min_max_result.min = minNum;\n        min_max_result.max = maxNum;\n        min_max_result.inOrder = inOrder;\n        return min_max_result;\n    }\n    const min_max_result = {\n        min: 0,\n        max: 0,\n        inOrder: false,\n    };\n\n    function identity(a) {\n        return a;\n    }\n\n    function turboSort(array, size, func) {\n        if(array) {\n            size = size ? Math.min(size,array.length) : array.length;\n            if(size > 1) {\n                indexFunction = func ? func : identity;\n                turboSortHelper(array, 0, size);\n            }\n        }\n    }\n\n    function sorted(array, offset, length) {\n        for(let i=1; i<length;i++) {\n            if(indexFunction(array[offset + i-1]) > indexFunction(array[offset + i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function minimum(array, offset, length) {\n        let mini = indexFunction(array[offset]);\n        for(let i=1;i<length;i++) {\n            const val = indexFunction(array[offset + i]);\n            if(val < mini) {\n                mini = val;\n            }\n        }\n        return mini;\n    }\n\n    function maximum(array, offset, length) {\n        let maxi = indexFunction(array[offset]);\n        for(let i=1;i<length;i++) {\n            const val = indexFunction(array[offset + i]);\n            if(val > maxi) {\n                maxi = val;\n            }\n        }\n        return maxi;\n    }\n\n    function quickSort(array, size, func) {\n        if(array) {\n            size = size ? Math.min(size,array.length) : array.length;\n            if(size > 1) {\n                indexFunction = func ? func : identity;\n                quickSortHelper(array, 0, size-1);\n            }\n        }\n    }\n\n    function quickSortHelper(items, left, right) {\n\n        var index;\n\n        if (items.length > 1) {\n\n            index = partition(items, left, right);\n\n            if (left < index - 1) {\n                quickSortHelper(items, left, index - 1);\n            }\n\n            if (index < right) {\n                quickSortHelper(items, index, right);\n            }\n\n        }\n\n        return items;\n    }\n\n\n    function partition(items, left, right) {\n\n        var pivot   = items[Math.floor((right + left) / 2)],\n            i       = left,\n            j       = right;\n\n\n        while (i <= j) {\n\n            while (indexFunction(items[i]) < indexFunction(pivot)) {\n                i++;\n            }\n\n            while (indexFunction(items[j]) > indexFunction(pivot)) {\n                j--;\n            }\n\n            if (i <= j) {\n                swap(items, i, j);\n                i++;\n                j--;\n            }\n        }\n\n        return i;\n    }\n\n\n    function turboSortHelper(array, offset, length) {\n        const arrayInfo = getMinMax(array, offset, length);\n        if(sorted(array, offset, length)) {\n            return;\n        }\n        if(length<1000) {\n            quickSortHelper(array, offset, offset + length - 1);\n            return;\n        }\n\n        const min = minimum(array, offset, length);\n        const max = maximum(array, offset, length);\n        const range = max-min;\n        if(range===0) {\n            return;\n        }\n\n        const bucketSize = Math.min(length, SIZE);\n\n        let i, index;\n        for(i=0; i<bucketSize; i++) {\n            counts[i] = 0;\n        }\n        counts[bucketSize] = 1;\n        for(i=0; i<length; i++) {\n            index = Math.floor((bucketSize-1) * (indexFunction(array[i+offset]) - min)/range);\n            counts[index]++;\n        }\n\n        for(i=0; i<bucketSize; i++) {\n            buckets[i] = 0;\n        }\n        buckets[bucketSize] = offset + length;\n        buckets[0] = offset;\n        for(i=1; i<bucketSize; i++) {\n            buckets[i] = buckets[i-1] + counts[i-1];\n        }\n\n        let voyager = offset, bucketId = 0;\n        while(bucketId<bucketSize) {\n            index = Math.floor((bucketSize-1) * (indexFunction(array[voyager]) - min)/range);\n            const newSpot = buckets[index] + --counts[index];\n            swap(array,voyager,newSpot);\n            while(!counts[bucketId]) {\n                bucketId++;\n            }\n            voyager = buckets[bucketId];\n        }\n        for(i=0; i<bucketSize; i++) {\n            counts[i] = buckets[i + 1] - buckets[i];\n        }\n        for(i=0; i<bucketSize; i++) {\n            if(counts[i] > 1) {\n                turboSortHelper(array, buckets[i], counts[i]);\n            }\n        }\n    }\n\n    function swap(array, a, b) {\n        const temp = array[a];\n        array[a] = array[b];\n        array[b] = temp;\n    }\n    return {\n        turbosort: turboSort,\n        quicksort: quickSort,\n    };\n})();\n"]}