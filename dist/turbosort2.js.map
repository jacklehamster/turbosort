{"version":3,"sources":["../turbosort2.js"],"names":["turbosort2","SIZE","buckets","Uint32Array","counts","indexFunction","identity","getMinMax","array","offset","length","firstIndex","minNum","maxNum","previousNum","inOrder","i","index","min_max_result","min","max","a","turboSort","size","func","Math","turboSortHelper","setIndexer","element","setOrder","start","Date","now","valuesPtr","Module","_malloc","Float64Array","BYTES_PER_ELEMENT","indexesPtr","HEAPF64","n","console","log","ccall","HEAPU32","dest","swap","temp","_free","b"],"mappings":"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","file":"turbosort2.js","sourcesContent":["var turbosort2 = (function() {\n\n    const SIZE = 1000000;\n    const buckets = new Uint32Array(SIZE+1);\n    const counts = new Uint32Array(SIZE+1);\n    let indexFunction = identity;\n\n    /**\n     *  FUNCTION DEFINITIONS\n     */\n    function getMinMax(array, offset, length) {\n        let firstIndex = indexFunction(array[offset]);\n        let minNum = firstIndex;\n        let maxNum = firstIndex;\n        let previousNum = firstIndex;\n        let inOrder = true;\n        for(let i=1; i<length; i++) {\n            const index = indexFunction(array[offset+i]);\n            if(previousNum > index) {\n                inOrder = false;\n                if(index < minNum) {\n                    minNum = index;\n                }\n            } else {\n                if(index > maxNum) {\n                    maxNum = index;\n                }\n            }\n            previousNum = index;\n        }\n        min_max_result.min = minNum;\n        min_max_result.max = maxNum;\n        min_max_result.inOrder = inOrder;\n        return min_max_result;\n    }\n    const min_max_result = {\n        min: 0,\n        max: 0,\n        inOrder: false,\n    };\n\n    function identity(a) {\n        return a;\n    }\n\n    function turboSort(array, size, func) {\n        if(array) {\n            size = size ? Math.min(size,array.length) : array.length;\n            if(size > 1) {\n                indexFunction = func ? func : identity;\n                turboSortHelper(array, 0, size ? size : array.length);\n            }\n        }\n    }\n\n\n    function setIndexer(element, index, array) {\n        array[index] = indexFunction(element);\n    }\n\n    function setOrder() {\n    }\n\n    function turboSortHelper(array, offset, length) {\n//        Float32Array.BYTES_PER_ELEMENT;\n//        var values = new Float32Array(length);\n        var start = Date.now();\n        var valuesPtr = Module._malloc(length * Float64Array.BYTES_PER_ELEMENT);\n        var indexesPtr = Module._malloc(length * Uint32Array.BYTES_PER_ELEMENT);\n        for(let i=0; i<length; i++) {\n            Module.HEAPF64[(valuesPtr / Float64Array.BYTES_PER_ELEMENT) + i] = indexFunction(array[i]);\n//            Module.HEAPU32[(indexesPtr / Uint32Array.BYTES_PER_ELEMENT) + i] = i;\n        }\n\n        var n = Date.now();\n        console.log(n-start);\n        start = n;\n\n//        debugger;\n        //1000000\n//        var bucketsPtr = Module._malloc((SIZE+1) * Uint32Array.BYTES_PER_ELEMENT);\n  //      var countsPtr = Module._malloc((SIZE+1) * Uint32Array.BYTES_PER_ELEMENT);\n//        var indexes = new Uint32Array(length);\n//        indexes.forEach(function(element, index, indexes) {\n//            indexes[index] = index;\n//        });\n\n//        console.log(values, indexes);\n\n   //     var valuesBytes = values.length * values.BYTES_PER_ELEMENT;\n //       var valuesPtr = Module._malloc(valuesBytes);\n//        console.log(valuesBytes, values.BYTES_PER_ELEMENT, valuesPtr);\n        //Module.HEAPF32.set(values, valuesPtr  >> 2);\n\n        /*\n         var samples = new Float32Array(1024);\n         var buffer = Module._malloc(1024*4);\n         Module.HEAPF32.set(samples, buffer >> 2);\n         Module._free(buffer);\n\n         */\n\n//        var dataHeap = new Uint8Array(Module.HEAPU8.buffer, ptr, valuesBytes);\n  //      dataHeap.set(new Uint8Array(values.buffer));\n\n\n //       var indexesBytes = indexes.length * indexes.BYTES_PER_ELEMENT;\n//        var indexesPtr = Module._malloc(indexesBytes);\n  //      Module.HEAPU32.set(indexes, indexesPtr >> 2);\n\n        Module.ccall('turbosort', 'void', ['number', 'number', 'number'], [valuesPtr, indexesPtr, length]);\n\n        var n = Date.now();\n        console.log(n-start);\n        start = n;\n\n//        [3,2,0,1];\n  //      [a,b,c,d]\n    //    [d,b,c,A] 0\n    //    [d,A,c,b]\n    //    [d,c,A,b]\n    //    [d,c,a,b]\n\n\n    //    [2,3,0,1]\n    //    [a,b,c,d]\n    //    [c,b,A,d] 0\n    //    [c,b,a,d]\n    //    [c,d,a,B] 1\n    //    [c,d,a,b]\n\n\n    //[2 3 1 0]\n    //[a,b,c,d]\n    //[0 1 2 3]\n    //[d c a b]\n\n        //[2 3 1 0]\n        //[a,b,c,d]\n        //[1 3 2 0]\n        //[c b a d]\n        //[3 1 2 0]\n        //[b c a d]\n        //[0 1 2 3]\n        //[d c a b]\n\n        var offset = (indexesPtr / Uint32Array.BYTES_PER_ELEMENT);\n        for(let i=0; i<length; i++) {\n            while(Module.HEAPU32[offset + i] !== i) {\n                let dest = Module.HEAPU32[offset + i];\n                //swap i and dest\n                swap(array, i, dest);\n\n                const temp = Module.HEAPU32[offset + i];\n                Module.HEAPU32[offset + i] = Module.HEAPU32[offset + dest];\n                Module.HEAPU32[offset + dest] = temp;\n            }\n        }\n\n        var n = Date.now();\n        console.log(n-start);\n        start = n;\n\n//        console.log(Module.HEAPF32.subarray(valuesPtr /Float32Array.BYTES_PER_ELEMENT, (valuesPtr /Float32Array.BYTES_PER_ELEMENT)+length));\n  //      console.log(Module.HEAPU32.subarray(indexesPtr /Uint32Array.BYTES_PER_ELEMENT, (indexesPtr /Uint32Array.BYTES_PER_ELEMENT)+length));\n//        array.forEach(function(element, index) {\n//            Module.HEAPF32[(valuesPtr / Float32Array.BYTES_PER_ELEMENT) + index] = indexFunction(element);\n  //          Module.HEAPU32[(indexesPtr / Uint32Array.BYTES_PER_ELEMENT) + index] = index;\n//        });\n\n        Module._free(valuesPtr);\n        Module._free(indexesPtr);\n//        Module._free(bucketsPtr);\n  //      Module._free(countsPtr);\n// Get data byte size, allocate memory on Emscripten heap, and get pointer\n//        var nDataBytes = data.length * data.BYTES_PER_ELEMENT;\n  //      var dataPtr = Module._malloc(nDataBytes);\n\n// Copy data to Emscripten heap (directly accessed from Module.HEAPU8)\n    //    var dataHeap = new Uint8Array(Module.HEAPU8.buffer, ptr, nDataBytes);\n      //  dataHeap.set(new Uint8Array(data.buffer));\n\n// Call function and get result\n//        float_multiply_array(2, dataHeap.byteOffset, data.length);\n  //      var result = new Float32Array(dataHeap.buffer, dataHeap.byteOffset, data.length);\n\n// Free memory\n    //    Module._free(dataHeap.byteOffset);\n\n/*        const myArray = new Uint8Array([100, 200, 250]);\n\n        const buffer = Module._malloc(myArray.length);\n        Module.HEAPU8.set(myArray, buffer);\n\n        Module.ccall('addThree', 'number', ['number', 'number'], [buffer, myArray.length]);\n\n        console.log(Module.HEAPU8.subarray(buffer, buffer+myArray.length));\n\n        Module._free(buffer);*/\n        var n = Date.now();\n        console.log(n-start);\n        start = n;\n\n    }\n\n    function swap(array, a, b) {\n        const temp = array[a];\n        array[a] = array[b];\n        array[b] = temp;\n    }\n    return turboSort;\n})();\n"]}